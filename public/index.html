<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YouTube Channel Check</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>

  <body>
    <!--
      ==========================================================
      TOPBAR / HEADER
      ==========================================================
      - Nur UI: Titel + Link zu "Collections ansehen"
      - Der Server läuft lokal auf http://localhost:3000
    -->
    <header class="topbar">
      <div class="container topbar__inner">
        <div class="brand">
          <div class="brand__text">
            <div class="brand__title">YouTubeChannelCheck</div>
            <div class="brand__subtitle">SocialBlade → YouTube → MongoDB</div>
          </div>
        </div>

        <div class="topbar__right">
          <a href="/collections" class="btn">Collections ansehen</a>
          <span class="pill">Server: <b>http://localhost:3000</b></span>
        </div>
      </div>
    </header>

    <main class="container">
      <!--
        ==========================================================
        HERO / ERKLÄRUNG OBEN
        ==========================================================
        Du hast ZWEI Wege um Prozess 1 zu starten:

        (A) NORMAL (sb-html):
            - Du lädst SocialBlade HTML-Dateien hoch (Upload).
            - Sie landen in /input.
            - Dann klickst du "Start Prozess 1 (input → ungefiltert)"
              -> Server liest HTML-Dateien aus /input.

        (B) SPEZIAL (sb-special):
            - Du hast fertige SocialBlade-Linklisten (Textdateien) in /inputYT.
            - Du klickst "Start Prozess 1 (inputYT → ungefiltert)"
              -> Server liest Linklisten aus /inputYT und extrahiert daraus SocialBlade URLs.

        Danach startest du Prozess 2:
            - (ungefiltert → vorgefiltertCode) mit deinen Regeln
      -->
      <section class="hero">
        <h1>Import & Prüfung von YouTube-Kanälen</h1>
        <p>
          Prozess 1 sammelt Kanäle aus SocialBlade-Quellen und schreibt sie nach
          <b>ungefiltert</b>. Danach prüft Prozess 2 die Regeln und schreibt
          „bestehende“ Kanäle nach <b>vorgefiltertCode</b>.
        </p>
      </section>

      <section class="grid">
        <!--
          ==========================================================
          OPTION 1 CARD
          ==========================================================
          - Upload von SocialBlade HTML
          - Start Prozess 1 im NORMAL-Modus
          - Start Prozess 1 im SPEZIAL-Modus (inputYT)
          - Start Prozess 2 (Filter-Regeln)
        -->
        <div class="card card--full">
          <div class="card__head">
            <h2>Option 1 (SocialBlade)</h2>
            <span class="tag tag--ok">Aktiv</span>
          </div>

          <p class="muted">
            <b>Normal:</b> Lade SocialBlade <b>.html</b> Dateien hoch.<br />
            Sie werden in den Ordner <code>/input</code> gespeichert.
          </p>

          <div class="row">
            <label class="btn btn--ghost">
              Dateien auswählen
              <input
                id="filesOption1"
                type="file"
                multiple
                accept=".html,.htm"
                hidden
              />
            </label>

            <button id="btnUpload1" class="btn btn--primary">Hochladen</button>
          </div>

          <div class="divider"></div>

          <!--
            ==========================================================
            PROZESS 1 (NORMAL)
            ==========================================================
            - Startet den Server-Endpunkt /process/sb-html-to-db
            - Body: { inputMode: "sb-html" } oder einfach {}
            - Server nutzt dann DEFAULT_INPUT_DIR (/input)
          -->
          <button id="btnProcessSbToDb" class="btn btn--success btn--wide">
            Start Prozess 1 (input → ungefiltert)
          </button>

          <div class="divider"></div>

          <!--
            ==========================================================
            PROZESS 1 (SPEZIAL: inputYT)
            ==========================================================
            - Startet den GLEICHEN Endpunkt: /process/sb-html-to-db
            - ABER mit Body:
                { inputMode: "sb-special", inputDir: "inputYT" }
            - Dadurch nutzt dein runJob() den Spezial-Branch
              und liest Linklisten aus /inputYT.
          -->
          <button
            id="btnProcessSbToDbInputYT"
            class="btn btn--success btn--wide"
          >
            Start Prozess 1 (inputYT → ungefiltert)
          </button>

          <div class="divider"></div>

          <!--
            ==========================================================
            PROZESS 2 (FILTER: ungefiltert → vorgefiltertCode)
            ==========================================================
            WICHTIG: Die Options-Namen müssen zu deiner server.js passen.

            In deiner server.js heißen die Parameter:
              - minDistinctGermanWordsTotal
              - maxBadCharsDistinctPerField

            (Nicht mehr: minDistinctGermanWords)
          -->
          <button
            id="btnProcessVorgefiltertToCode"
            class="btn btn--success btn--wide"
            title="Filtert deutsche Kanäle nach Regeln und schreibt in vorgefiltertCode"
          >
            Start Prozess 2 (ungefiltert → vorgefiltertCode)
          </button>

          <div class="hint">
            Tipp: Für den Normal-Flow: Erst hochladen → Prozess 1 (input) →
            Prozess 2.
            <br />
            Für Tests: Prozess 1 (inputYT) → Prozess 2.
          </div>
        </div>
      </section>

      <!--
        ==========================================================
        STATUS + OUTPUT PANEL
        ==========================================================
        - Status zeigt dir "Bereit / Work / Ok / Warn / Error"
        - Output zeigt JSON Boxen + Live Logs
      -->
      <section class="panel">
        <div class="panel__head">
          <h3>Status & Ergebnis</h3>
          <div class="panel__actions">
            <button id="btnClear" class="btn btn--ghost">
              Ausgabe löschen
            </button>
          </div>
        </div>

        <div id="status" class="status status--idle">
          <div class="status__dot"></div>
          <div>
            <div class="status__title">Bereit</div>
            <div class="status__text">
              Wähle Dateien aus und starte den Upload.
            </div>
          </div>
        </div>

        <div id="output" class="output"></div>
      </section>
    </main>

    <footer class="footer">
      <div class="container footer__inner">
        <span class="muted">© YouTubeChannelCheck</span>
        <span class="muted"
          >MongoDB Collections: ungefiltert / vorgefiltertCode</span
        >
      </div>
    </footer>

    <script>
      /**
       * ==========================================================
       * UI-HELPER
       * ==========================================================
       * - $() spart Tipparbeit bei document.getElementById
       * - setStatus(...) setzt Klasse + Texte in der Statusbox
       * - escapeHtml(...) schützt vor HTML-Injection im Output (wichtig)
       * - renderJsonBox(...) rendert JSON schön als Box
       */
      const $ = (id) => document.getElementById(id);

      function setStatus(type, title, text) {
        const status = $("status");
        status.className = "status status--" + type;
        status.querySelector(".status__title").textContent = title;
        status.querySelector(".status__text").textContent = text;
      }

      function escapeHtml(str) {
        return String(str ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function renderJsonBox(title, obj) {
        return `
          <div class="box">
            <div class="box__title">${escapeHtml(title)}</div>
            <pre class="code">${escapeHtml(JSON.stringify(obj, null, 2))}</pre>
          </div>
        `;
      }

      /**
       * ==========================================================
       * UPLOAD OPTION 1 (HTML → /input)
       * ==========================================================
       * - Frontend sendet FormData an /upload/option1
       * - Server speichert Dateien in DEFAULT_INPUT_DIR (/input)
       */
      $("btnUpload1").addEventListener("click", async () => {
        const input = $("filesOption1");

        if (!input.files || input.files.length === 0) {
          setStatus(
            "warn",
            "Keine Dateien ausgewählt",
            "Bitte zuerst .html/.htm Dateien auswählen."
          );
          return;
        }

        setStatus(
          "work",
          "Upload läuft…",
          `${input.files.length} Datei(en) werden hochgeladen.`
        );

        const form = new FormData();
        for (const file of input.files) form.append("files", file);

        try {
          const res = await fetch("/upload/option1", {
            method: "POST",
            body: form,
          });
          const data = await res.json();

          if (!res.ok || !data.ok)
            throw new Error(data.error || "Upload fehlgeschlagen");

          setStatus(
            "ok",
            "Upload fertig ✅",
            `${data.savedCount} Datei(en) in /input gespeichert.`
          );
          $("output").innerHTML =
            renderJsonBox("Upload Ergebnis", data) + $("output").innerHTML;
        } catch (e) {
          setStatus("err", "Upload Fehler ❌", e.message);
        }
      });

      /**
       * ==========================================================
       * JOB STARTER (wiederverwendbar)
       * ==========================================================
       * startJob(endpoint, bodyObj)
       * - POSTet JSON an endpoint
       * - Server antwortet mit jobId + stream URL
       * - Wir öffnen EventSource /api/jobs/:jobId/stream
       * - Wir zeigen live:
       *    - Step
       *    - Progress
       *    - Logs
       */
      async function startJob(endpoint, bodyObj) {
        setStatus(
          "work",
          "Prozess läuft…",
          "Job wird gestartet… (Live-Logs folgen)"
        );

        // Live-Log Box oben einfügen
        const logBoxId = "liveLogBox";
        const liveBoxHtml = `
          <div class="box" id="${logBoxId}">
            <div class="box__title">Live Status (Job)</div>
            <div class="box__body">
              <div class="muted small" id="jobMeta">Job: —</div>
              <div class="muted small" id="jobStep">Step: —</div>
              <div class="muted small" id="jobProgress">Progress: —</div>
              <div class="divider"></div>
              <pre class="code" id="jobLogs" style="max-height:320px; overflow:auto;"></pre>
            </div>
          </div>
        `;
        $("output").innerHTML = liveBoxHtml + $("output").innerHTML;

        const jobMetaEl = document.getElementById("jobMeta");
        const jobStepEl = document.getElementById("jobStep");
        const jobProgressEl = document.getElementById("jobProgress");
        const jobLogsEl = document.getElementById("jobLogs");

        function appendLog(line) {
          jobLogsEl.textContent += line + "\n";
          jobLogsEl.scrollTop = jobLogsEl.scrollHeight;
        }

        let es = null;

        try {
          const res = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(bodyObj || {}),
          });

          const startData = await res.json();
          if (!res.ok || !startData.ok)
            throw new Error(startData.error || "Job-Start fehlgeschlagen");

          const jobId = startData.jobId;
          jobMetaEl.textContent = `Job: ${jobId}`;
          appendLog(`[client] Job gestartet: ${jobId}`);

          es = new EventSource(`/api/jobs/${encodeURIComponent(jobId)}/stream`);

          es.addEventListener("snapshot", (ev) => {
            const snap = JSON.parse(ev.data);

            jobStepEl.textContent = `Step: ${snap.step || "—"}`;
            const cur = snap.progress?.current ?? 0;
            const total = snap.progress?.total ?? 0;
            jobProgressEl.textContent = total
              ? `Progress: ${cur}/${total}`
              : "Progress: —";

            if (snap.status === "done") {
              setStatus("ok", "Prozess fertig ✅", "Job abgeschlossen.");
              appendLog("[server] Job DONE ✅");

              if (snap.stats) {
                $("output").innerHTML =
                  renderJsonBox("Job Ergebnis (Stats)", snap.stats) +
                  $("output").innerHTML;
              }

              es.close();
            }

            if (snap.status === "error") {
              setStatus(
                "err",
                "Prozess Fehler ❌",
                snap.error || "Unbekannter Fehler"
              );
              appendLog(`[server] Job ERROR ❌: ${snap.error || "unbekannt"}`);
              es.close();
            }
          });

          es.addEventListener("log", (ev) => {
            const l = JSON.parse(ev.data);
            const prefix =
              l.level === "err" ? "❌" : l.level === "warn" ? "⚠️" : "ℹ️";
            appendLog(
              `${prefix} ${l.t} — ${l.message}${
                l.extra ? " " + JSON.stringify(l.extra) : ""
              }`
            );
          });

          es.addEventListener("ping", () => {});
          es.onerror = () =>
            appendLog("[client] SSE Verbindung unterbrochen (onerror).");
        } catch (e) {
          setStatus("err", "Prozess Fehler ❌", e.message);
          appendLog(`[client] ERROR: ${e.message}`);
          if (es) es.close();
        }
      }

      /**
       * ==========================================================
       * PROZESS 1 (NORMAL /input)
       * ==========================================================
       * - Du hast zwei Möglichkeiten, beide funktionieren:
       *    1) {} senden (Server default: sb-html + /input)
       *    2) explizit inputMode: "sb-html" senden
       * - Ich sende hier explizit, damit es klar ist.
       */
      $("btnProcessSbToDb").addEventListener("click", async () => {
        await startJob("/process/sb-html-to-db", {
          inputMode: "sb-html",
          // inputDir NICHT setzen -> server nutzt DEFAULT_INPUT_DIR (= /input)
        });
      });

      /**
       * ==========================================================
       * PROZESS 1 (SPEZIAL /inputYT)
       * ==========================================================
       * - Der Server braucht:
       *    inputMode: "sb-special"
       *    inputDir: "inputYT"
       * - Dann nimmt runJob() automatisch den Spezial-Branch und
       *   ruft loadChannelsFromSbLinkFolder(...) auf.
       */
      $("btnProcessSbToDbInputYT").addEventListener("click", async () => {
        await startJob("/process/sb-html-to-db", {
          inputMode: "sb-special",
        });
      });

      /**
       * ==========================================================
       * PROZESS 2 (ungefiltert → vorgefiltertCode)
       * ==========================================================
       * WICHTIG: Deine server.js erwartet diese Options-Namen:
       *   - minDistinctGermanWordsTotal
       *   - maxBadCharsDistinctPerField
       *
       * Deshalb setzen wir die hier korrekt.
       */
      $("btnProcessVorgefiltertToCode").addEventListener("click", async () => {
        await startJob("/process/ungefiltert-to-vorgefiltertCode", {
          // ✅ korrekte Namen für deine server.js:
          minDistinctGermanWordsTotal: 4,
          maxBadCharsDistinctPerField: 3,

          dryRun: false,
          limit: 0,

          // Optional:
          // deutschArray: [...],
          // badCharArray: [...],
        });
      });

      /**
       * ==========================================================
       * OUTPUT CLEAR
       * ==========================================================
       */
      $("btnClear").addEventListener("click", () => {
        $("output").innerHTML = "";
        setStatus("idle", "Bereit", "Wähle Dateien aus und starte den Upload.");
      });
    </script>
  </body>
</html>
