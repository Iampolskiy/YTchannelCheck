<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YouTube Channel Check</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>

  <body>
    <!--
      ==========================================================
      TOPBAR / HEADER
      ==========================================================
      - Nur UI: Titel + Links
      - WICHTIG: Link zu /adjust ist schon da ✅
    -->
    <header class="topbar">
      <div class="container topbar__inner">
        <div class="brand">
          <div class="brand__text">
            <div class="brand__title">YouTubeChannelCheck</div>
            <div class="brand__subtitle">SocialBlade → YouTube → MongoDB</div>
          </div>
        </div>

        <div class="topbar__right">
          <a href="/adjust" class="btn btn--ghost">Einstellungen</a>
          <a href="/collections" class="btn">Collections ansehen</a>
          <span class="pill">Server: <b>http://localhost:3000</b></span>
        </div>
      </div>
    </header>

    <main class="container">
      <section class="hero">
        <h1>Import & Prüfung von YouTube-Kanälen</h1>
        <p>
          Prozess 1 sammelt Kanäle aus SocialBlade-Quellen und schreibt sie nach
          <b>ungefiltert</b>. Danach prüft Prozess 2 die Regeln und schreibt
          „bestehende“ Kanäle nach <b>vorgefiltertCode</b>.
        </p>
      </section>

      <section class="grid">
        <div class="card card--full">
          <div class="card__head">
            <h2>Option 1 (SocialBlade)</h2>
            <span class="tag tag--ok">Aktiv</span>
          </div>

          <p class="muted">
            <b>Normal:</b> Lade SocialBlade <b>.html</b> Dateien hoch.<br />
            Sie werden in den Ordner <code>/input</code> gespeichert.
          </p>

          <div class="row">
            <label class="btn btn--ghost">
              Dateien auswählen
              <input
                id="filesOption1"
                type="file"
                multiple
                accept=".html,.htm"
                hidden
              />
            </label>

            <button id="btnUpload1" class="btn btn--primary">Hochladen</button>
          </div>

          <div class="divider"></div>

          <button id="btnProcessSbToDb" class="btn btn--success btn--wide">
            Start Prozess 1 (input → ungefiltert)
          </button>

          <div class="divider"></div>

          <button
            id="btnProcessSbToDbInputYT"
            class="btn btn--success btn--wide"
          >
            Start Prozess 1 (inputYT → ungefiltert)
          </button>

          <div class="divider"></div>

          <button
            id="btnProcessVorgefiltertToCode"
            class="btn btn--success btn--wide"
            title="Filtert deutsche Kanäle nach Regeln und schreibt in vorgefiltertCode"
          >
            Start Prozess 2 (ungefiltert → vorgefiltertCode)
          </button>

          <div class="hint">
            Tipp: Für den Normal-Flow: Erst hochladen → Prozess 1 (input) →
            Prozess 2.
            <br />
            Für Tests: Prozess 1 (inputYT) → Prozess 2.
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel__head">
          <h3>Status & Ergebnis</h3>
          <div class="panel__actions">
            <button id="btnClear" class="btn btn--ghost">
              Ausgabe löschen
            </button>
          </div>
        </div>

        <div id="status" class="status status--idle">
          <div class="status__dot"></div>
          <div>
            <div class="status__title">Bereit</div>
            <div class="status__text">
              Wähle Dateien aus und starte den Upload.
            </div>
          </div>
        </div>

        <div id="output" class="output"></div>
      </section>
    </main>

    <footer class="footer">
      <div class="container footer__inner">
        <span class="muted">© YouTubeChannelCheck</span>
        <span class="muted"
          >MongoDB Collections: ungefiltert / vorgefiltertCode</span
        >
      </div>
    </footer>

    <script>
      /**
       * ==========================================================
       * WICHTIG: Verbindung zu adjust.html (localStorage)
       * ==========================================================
       * adjust.html speichert in localStorage unter diesem Key:
       *   OPTIONS_KEY = "ytcheck_options_v1"
       *
       * index.html lädt diese Settings beim Start von Prozess 2
       * und sendet sie 1:1 an:
       *   POST /process/ungefiltert-to-vorgefiltertCode
       */
      const OPTIONS_KEY = "ytcheck_options_v1";

      /**
       * Defaults (falls noch nichts gespeichert ist).
       * Diese Werte sind IDENTISCH zu adjust.html.
       */
      const DEFAULTS = {
        minDescriptionChars: 10,
        maxBadCharsDistinctPerField: 3,

        minGermanWordsBase: 3,
        wordsPerRequiredGerman: 80,
        maxGermanWordsCap: 25,

        kidsHardDistinctThreshold: 2,
        addictionHardDistinctThreshold: 2,
        combatSportsDistinctThreshold: 2,

        writeDeletedChannels: true,
        dryRun: false,
        limit: 0,
      };

      function safeParseJson(raw) {
        try {
          const obj = JSON.parse(raw);
          return obj && typeof obj === "object" ? obj : null;
        } catch {
          return null;
        }
      }

      /**
       * loadSavedOptions():
       * - holt die gespeicherten Settings aus localStorage
       * - merged sie über DEFAULTS (damit nie Keys fehlen)
       */
      function loadSavedOptions() {
        const raw = localStorage.getItem(OPTIONS_KEY);
        const parsed = raw ? safeParseJson(raw) : null;
        return { ...DEFAULTS, ...(parsed || {}) };
      }

      /**
       * ==========================================================
       * UI-HELPER
       * ==========================================================
       */
      const $ = (id) => document.getElementById(id);

      function setStatus(type, title, text) {
        const status = $("status");
        status.className = "status status--" + type;
        status.querySelector(".status__title").textContent = title;
        status.querySelector(".status__text").textContent = text;
      }

      function escapeHtml(str) {
        return String(str ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function renderJsonBox(title, obj) {
        return `
          <div class="box">
            <div class="box__title">${escapeHtml(title)}</div>
            <pre class="code">${escapeHtml(JSON.stringify(obj, null, 2))}</pre>
          </div>
        `;
      }

      /**
       * ==========================================================
       * UPLOAD OPTION 1 (HTML → /input)
       * ==========================================================
       */
      $("btnUpload1").addEventListener("click", async () => {
        const input = $("filesOption1");

        if (!input.files || input.files.length === 0) {
          setStatus(
            "warn",
            "Keine Dateien ausgewählt",
            "Bitte zuerst .html/.htm Dateien auswählen."
          );
          return;
        }

        setStatus(
          "work",
          "Upload läuft…",
          `${input.files.length} Datei(en) werden hochgeladen.`
        );

        const form = new FormData();
        for (const file of input.files) form.append("files", file);

        try {
          const res = await fetch("/upload/option1", {
            method: "POST",
            body: form,
          });
          const data = await res.json();

          if (!res.ok || !data.ok)
            throw new Error(data.error || "Upload fehlgeschlagen");

          setStatus(
            "ok",
            "Upload fertig ✅",
            `${data.savedCount} Datei(en) in /input gespeichert.`
          );
          $("output").innerHTML =
            renderJsonBox("Upload Ergebnis", data) + $("output").innerHTML;
        } catch (e) {
          setStatus("err", "Upload Fehler ❌", e.message);
        }
      });

      /**
       * ==========================================================
       * JOB STARTER (wiederverwendbar)
       * ==========================================================
       */
      async function startJob(endpoint, bodyObj) {
        setStatus(
          "work",
          "Prozess läuft…",
          "Job wird gestartet… (Live-Logs folgen)"
        );

        const logBoxId = "liveLogBox";
        const liveBoxHtml = `
          <div class="box" id="${logBoxId}">
            <div class="box__title">Live Status (Job)</div>
            <div class="box__body">
              <div class="muted small" id="jobMeta">Job: —</div>
              <div class="muted small" id="jobStep">Step: —</div>
              <div class="muted small" id="jobProgress">Progress: —</div>
              <div class="divider"></div>
              <pre class="code" id="jobLogs" style="max-height:320px; overflow:auto;"></pre>
            </div>
          </div>
        `;
        $("output").innerHTML = liveBoxHtml + $("output").innerHTML;

        const jobMetaEl = document.getElementById("jobMeta");
        const jobStepEl = document.getElementById("jobStep");
        const jobProgressEl = document.getElementById("jobProgress");
        const jobLogsEl = document.getElementById("jobLogs");

        function appendLog(line) {
          jobLogsEl.textContent += line + "\n";
          jobLogsEl.scrollTop = jobLogsEl.scrollHeight;
        }

        let es = null;

        try {
          // ✅ Für Debug super hilfreich: was senden wir wirklich?
          appendLog(
            "[client] Sende Options: " + JSON.stringify(bodyObj || {}, null, 0)
          );

          const res = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(bodyObj || {}),
          });

          const startData = await res.json();
          if (!res.ok || !startData.ok)
            throw new Error(startData.error || "Job-Start fehlgeschlagen");

          const jobId = startData.jobId;
          jobMetaEl.textContent = `Job: ${jobId}`;
          appendLog(`[client] Job gestartet: ${jobId}`);

          es = new EventSource(`/api/jobs/${encodeURIComponent(jobId)}/stream`);

          es.addEventListener("snapshot", (ev) => {
            const snap = JSON.parse(ev.data);

            jobStepEl.textContent = `Step: ${snap.step || "—"}`;
            const cur = snap.progress?.current ?? 0;
            const total = snap.progress?.total ?? 0;
            jobProgressEl.textContent = total
              ? `Progress: ${cur}/${total}`
              : "Progress: —";

            if (snap.status === "done") {
              setStatus("ok", "Prozess fertig ✅", "Job abgeschlossen.");
              appendLog("[server] Job DONE ✅");

              if (snap.stats) {
                $("output").innerHTML =
                  renderJsonBox("Job Ergebnis (Stats)", snap.stats) +
                  $("output").innerHTML;
              }

              es.close();
            }

            if (snap.status === "error") {
              setStatus(
                "err",
                "Prozess Fehler ❌",
                snap.error || "Unbekannter Fehler"
              );
              appendLog(`[server] Job ERROR ❌: ${snap.error || "unbekannt"}`);
              es.close();
            }
          });

          es.addEventListener("log", (ev) => {
            const l = JSON.parse(ev.data);
            const prefix =
              l.level === "err" ? "❌" : l.level === "warn" ? "⚠️" : "ℹ️";
            appendLog(
              `${prefix} ${l.t} — ${l.message}${
                l.extra ? " " + JSON.stringify(l.extra) : ""
              }`
            );
          });

          es.addEventListener("ping", () => {});
          es.onerror = () =>
            appendLog("[client] SSE Verbindung unterbrochen (onerror).");
        } catch (e) {
          setStatus("err", "Prozess Fehler ❌", e.message);
          if (jobLogsEl)
            jobLogsEl.textContent += `[client] ERROR: ${e.message}\n`;
          if (es) es.close();
        }
      }

      /**
       * ==========================================================
       * PROZESS 1 (NORMAL /input)
       * ==========================================================
       */
      $("btnProcessSbToDb").addEventListener("click", async () => {
        await startJob("/process/sb-html-to-db", {
          inputMode: "sb-html",
        });
      });

      /**
       * ==========================================================
       * PROZESS 1 (SPEZIAL /inputYT)
       * ==========================================================
       */
      $("btnProcessSbToDbInputYT").addEventListener("click", async () => {
        await startJob("/process/sb-html-to-db", {
          inputMode: "sb-special",
        });
      });

      /**
       * ==========================================================
       * ✅ PROZESS 2 (ungefiltert → vorgefiltertCode)
       * ==========================================================
       * DER ENTSCHEIDENDE FIX:
       * - Wir laden die gespeicherten Options aus adjust.html
       * - Und senden sie an den Server
       */
      $("btnProcessVorgefiltertToCode").addEventListener("click", async () => {
        const saved = loadSavedOptions();
        await startJob("/process/ungefiltert-to-vorgefiltertCode", saved);
      });

      /**
       * ==========================================================
       * OUTPUT CLEAR
       * ==========================================================
       */
      $("btnClear").addEventListener("click", () => {
        $("output").innerHTML = "";
        setStatus("idle", "Bereit", "Wähle Dateien aus und starte den Upload.");
      });
    </script>
  </body>
</html>
